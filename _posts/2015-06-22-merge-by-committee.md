---
title: "Merge by committee"
excerpt: ""
---

The hardest part of open source for any organization isn't security or legal concerns, or even the code itself. The hardest part of open source for large organizations is learning to work like an open source project. There is an emerging anti-pattern, whereby organizations review and discuss issues and pull requests in regularly scheduled, closed meetings, a practice that almost certainly sets the project up for failure.

A typical closed-source development workflow might include a project manager who gathers feature requirements, prioritizes tasks, and assigns them to a development team. The process will likely involve regular status meetings, and perhaps a daily standup meeting to resolve any blockers that emerge between status meetings. When issues arise, or when new features are requested, they're generally addressed at a separate project planning meeting. These meetings generally take place in conference rooms,

All too often, organizations attempt to graft this traditional, closed-source workflow to open source projects. Open source is more than simply publishing code. It's a workflow, a philosophy, the modern approach to building software, both inside and outside your firewall, and if you don't treat it as such, the organization and the open source community will almost certainly have a subpar experience.

One problem with trying to apply closed-source workflows to open source projects is that often only a small subset of the project's developers — those that happen to be on your organization's payroll — are invited to all those status, standup, and planning meetings. As decisions are made that affect the project, the majority of your project's stakeholders, both technical and non-technical, have no means of participating, nor can they contribute their experience or expertise. Not to mention, all the relevant technical details likely live in written discussion within the project's issue tracker, and it's unlikely that the outcomes of the meeting will be sufficiently memorialized to document what decisions were made and more importantly, why.

Another problem is that, while scheduled meetings work well when developers are in the same place and all work the same hours, open source projects are global, meaning it might be 3:00 AM for a developer in Tokyo, when you have your 2:00 PM planning call. By virtue of being distributed, open source is, by design and necessity, asynchronous and agile. It's not uncommon for an issue to be reported by a user in one time zone, confirmed with additional details by a user in another timezone, fixed by a contributor in a third, and closed by a maintainer half way around the world, all within the span of a few hours. The pace of an open source project is measured in minutes or hours, not weeks, or quarters.

You may see then, how such a distributed workflow is incongruous with only being able to make decisions that affect the project during a special one hour block at a weekly meeting. As a contributor, if I have to wait a week for feedback on my proposed change, a week for which I am administratively blocked, and then another week for it to me merged, it's unlikely that I'm going to contribute again.

I know of government agencies that have weekly standing meetings, where stakeholders gather, print out open issues and pull requests (becuase of course, there's no wifi), create an agenda, and discuss each one-by-one, assigning action items for individuals to reply to particular threads on behalf of the committee.

While a good first step would be to invite any project stakeholder, inside your organization or otherwise, to join, either in person or remotely, your still applying a highly centralized governance model to a decentralized workflow. It's a long-standing joke that design by committee produces terrible results. So why concentrate the project's authority in a slow-moving committee process?

Instead, organizations wishing to transition from traditional, closed-source workflows to more modern, open source approaches to software development should do two things:

1. **Decentralize governance** - Individual maintainers must be trusted and empowered to act in the project's best interest. If a user requests a new feature, project maintainers should provide feedback immediately, speaking as individuals, not on behalf of some semi-secret committee. if a contributor proposes a change, the code should be reviewed by a developer, and the merits discussed, as it's submitted. Naturally some issues will warrant a broader discussion, but whether technical or non-technical, individual maintainers should have the authority to run the project on a day-to-day basis.

2. **Minimize information embalance** - The problem with maintaining a closed-source workflow, while working in the open, is that you end up duplicating your efforts. Organization's often have two classes of stakeholders (those inside the organization, and those in the public), two means of requesting new features, two means of discussing proposed changes, and two means receiving project updates. This creates a significant ambulance, both in terms of information and the ability to contribute. Instead, your project should have one class of stakeholders, pushing internal discussions outside the firewall to the same tools external stakeholders have access to. Want to propose a feature? Open an issue. Think something's a bad idea? Comment on the pull request. If an external stakeholder doesn't have access to a given resource, you shouldn't use it until they do.
